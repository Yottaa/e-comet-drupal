<?php

/**
 * Yottaa API Class.
 */

class YottaaAPI {

  /**
   * The URL of the API.
   */
  private $api = 'https://api.yottaa.com/';

  /**
   * The API key.
   */
  private $key;

  /**
   * The user id.
   */
  private $uid;

  /**
   * The side id.
   */
  private $sid;

  /**
   * Constructor.
   */
  public function __construct($key, $uid, $sid) {
    $this->key = $key;
    $this->uid = $uid;
    $this->sid = $sid;
  }

  /**
   * Check if it has all required parameters.
   */
  public function isEmpty() {
    return empty($this->key) || empty($this->uid) || empty($this->sid);
  }

  /**
   * Create an account.
   */
  public function createAccount($name, $email, $phone, $site) {
    $user_id = '4d34f75b74b1553ba500007f';
    $api_key = '455df7500258012f663b12313d145ceb';

    if (is_array($name)) {
        $fname = isset($name['first_name']) ? $name['first_name'] : "";
        $lname = isset($name['last_name']) ? $name['last_name'] : "";
    } else {
        list($fname, $lname) = explode(" ", $name);
    }

    return $this->call('partners/' . $user_id . '/accounts', array(
      'first_name' => $fname,
      'last_name' => $lname,
      'email' => $email,
      'phone' => $phone,
      'site' => $site,
    ), 'POST', $api_key);
  }

  /**
   * Return site settings.
   */
  public function getSettings() {
    $result = $this->call('sites/' . $this->sid . '/settings', array(
      'user_id' => $this->uid,
    ), 'GET', $this->key);
    return $this->postProcessingSettings($result);
  }

  /**
   * Returns site status.
   */
  public function getStatus() {
    return $this->call('sites/' . $this->sid, array(
      'user_id' => $this->uid,
    ), 'GET', $this->key);
  }

  /**
   * Returns site status.
   */
  public function getRuntimeStatus($key,$uid,$sid) {
    return $this->call('sites/' . $sid, array(
      'user_id' => $uid,
    ), 'GET', $key);
  }

  /**
   * Flushes cache.
   */
  public function flush() {
    return $this->call('sites/' . $this->sid . '/flush_cache', array(
      'user_id' => $this->uid,
    ), 'PUT', $this->key);
  }

  /**
   * Flushes cache by path.
   */
  public function flushPaths($paths) {
    return $this->flush();
  }

  /**
   * Pause optimization.
   */
  public function pause() {
    return $this->call('optimizers/' . $this->sid . '/pause', array(
      'user_id' => $this->uid,
    ), 'PUT', $this->key);
  }

  /**
   * Resume optimization.
   */
  public function resume() {
    return $this->call('optimizers/' . $this->sid . '/resume', array(
      'user_id' => $this->uid,
    ), 'PUT', $this->key);
  }

  /**
   * Make an api call.
   */
  private function call($path, $params, $method, $key) {
    $output = $this->post_async($this->api . $path, $params, $method, $key);
    return json_decode($this->parseHttpResponse($output), TRUE);
  }

  /**
   * Make an api call.
   */
  private function post_async($url, $params, $method, $api_key) {
    foreach ($params as $key => &$val) {
      if (is_array($val)) $val = implode(',', $val);
      $post_params[] = $key . '=' . urlencode($val);
    }
    $post_string = implode('&', $post_params);

    $parts = parse_url($url);

    $fp = fsockopen("ssl://" . $parts['host'],
            isset($parts['port']) ? $parts['port'] : 443,
            $errno, $errstr, 30);

    // Data goes in the path for a GET request
    $parts['path'] .= '?' . $post_string;

    $out = $method . " " . $parts['path'] . " HTTP/1.1\r\n";
    $out .= "Host: " . $parts['host'] . "\r\n";
    $out .= "Content-Type: application/x-www-form-urlencoded\r\n";
    $out .= "Content-Length: 0\r\n";
    $out .= "YOTTAA-API-KEY: " . $api_key . "\r\n";
    $out .= "Connection: Close\r\n\r\n";

    fwrite($fp, $out);
    $result = "";
    while (!feof($fp)) {
      $result .= fgets($fp, 128);
    }
    fclose($fp);
    return $result;
  }

  /**
   * Accepts provided http content, checks for a valid http response,
   * unchunks if needed, returns http content without headers on
   * success, FALSE on any errors.
   *
   * @param NULL $content
   * @return bool|string
   */
  private function parseHttpResponse($content = NULL) {
    if (empty($content)) {
      return FALSE;
    }
    // split into array, headers and content.
    $hunks = explode("\r\n\r\n", trim($content));
    if (!is_array($hunks) or count($hunks) < 2) {
      return FALSE;
    }
    $header = $hunks[count($hunks) - 2];
    $body = $hunks[count($hunks) - 1];
    $headers = explode("\n", $header);
    unset($hunks);
    unset($header);
    if (!$this->validateHttpResponse($headers)) {
      return '{"error" : ' . trim($body) . '}';
      //return FALSE;
    }
    if (in_array('Transfer-Coding: chunked', $headers)) {
      return trim($this->unchunkHttpResponse($body));
    }
    else {
      return trim($body);
    }
  }

  /**
   * Validate http responses by checking header.  Expects array of
   * headers as argument.  Returns boolean.
   *
   * @param NULL $headers
   * @return bool
   */
  private function validateHttpResponse($headers = NULL) {
    if (!is_array($headers) or count($headers) < 1) {
      return FALSE;
    }
    switch (trim(strtolower($headers[0]))) {
      case 'http/1.0 100 ok':
      case 'http/1.0 200 ok':
      case 'http/1.1 100 ok':
      case 'http/1.1 200 ok':
        return TRUE;
        break;
    }
    return FALSE;
  }

  /**
   * Unchunk http content.  Returns unchunked content on success,
   * FALSE on any errors...  Borrows from code posted above by
   * jbr at ya-right dot com.
   *
   * @param NULL $str
   * @return bool|NULL|string
   */
  private function unchunkHttpResponse($str = NULL) {
    if (!is_string($str) or strlen($str) < 1) {
      return FALSE;
    }
    $eol = "\r\n";
    $add = strlen($eol);
    $tmp = $str;
    $str = '';
    do {
      $tmp = ltrim($tmp);
      $pos = strpos($tmp, $eol);
      if ($pos === FALSE) {
        return FALSE;
      }
      $len = hexdec(substr($tmp, 0, $pos));
      if (!is_numeric($len) or $len < 0) {
        return FALSE;
      }
      $str .= substr($tmp, ($pos + $add), $len);
      $tmp = substr($tmp, ($len + $pos + $add));
      $check = trim($tmp);
    } while (!empty($check));
    unset($tmp);
    return $str;
  }

  /**
   * Post-process settings return from Yottaa service.
   *
   * @param $json_output
   * @return array
   */
  protected function postProcessingSettings($json_output) {
      return array();
  }

}